# -*- coding: utf-8 -*-
"""midterm_ex1

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12ecFZfnoVPIBhQEAfA3uRheSNPYzrvjn

# 中間課題1

画像データのベクトル表現と処理

* Q1 5P
* Q2 5P
* Q3 15P
* Q4 25P

## 準備
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot  as plt
from sklearn import datasets
from sklearn.decomposition import PCA
from PIL import Image, ImageOps, ImageEnhance

"""Pythonの機械学習ライブラリであるscikit-learnの手書き数字データセットdigitsには以下に示すような手書き数字の画像と対応するラベルが含まれています。

データセットには1797個の手書き数字の画像データと対応するラベルデータが含まれています。

データセットは以下のキーと値を持つ辞書のような型になっています

* imagesキーに対する値は手書き数字画像のピクセルデータに対応しており`(`データ数, 縦幅のピクセル数, 横幅のピクセル数`)`の形状の3次元配列で表されています。実際の形状は`(1797, 8, 8)`です。
*	dataキーに対する値も同様に手書き数字画像のピクセルデータに対応しており`(`データ数, 縦幅のピクセル数×横幅のピクセル数`)`の形状の2次元配列で表されています。実際の形状は`(1797, 64)`です。
* targetキーに対応する値は手書き数字画像のラベルデータに対応しており`（`データ数,`）`の形状の1次元配列で表されています。実際の形状は`（1797,）`です。1次元配列の各要素は各画像に対応するラベル（整数型）となります。
"""

digits = datasets.load_digits()
for i in range(10):
    plt.subplot(2, 5, i+1)
    plt.axis('off')
    plt.title(digits.target[i])
    plt.imshow(digits.images[i], cmap='gray_r')

"""各画像データは次のように8行8列のピクセルデータで表されており、各ピクセルには白黒の濃淡に応じて0から16までの画素値が割り当てられています。


"""

n = 500
plt.imshow(digits.images[n], cmap='gray_r') # 手書き数字画像
plt.show()
print(digits.images[n]) #  2次元ピクセルデータ
print(digits.target[n]) # ラベル

"""各画像データは64（8×8）個の要素からなる1次元のピクセルデータとして表すこともできます。


"""

print(digits.data[n])  # 1次元ピクセルデータ

"""次のようにデータセットを1797行64列の行列を表す2次元配列`X`として保持します。
この時、`X`の各行は各画像の1次元のピクセルデータを表す特徴ベクトルに対応します。

また、1次元配列`y`の各要素は`X`の各行とそれぞれ対応しており、`X`の各行に対応する各画像が0から9のいずれかの数字であるかを表す整数のラベルとなっています。
"""

X = digits.data
y = digits.target

"""以下では、スマートフォンで撮影した手書き数字画像（数字の8）のファイルをダウンロードし、画像を表示しています。"""

!wget https://raw.githubusercontent.com/UTDataMining/2023A/master/data/8.jpeg

filename = '8.jpeg'
im = Image.open(filename)
plt.imshow(im, cmap='gray_r')
plt.show()

"""画像をdigitsデータセットの各画像と同様の8行8列の白黒のピクセルデータを表す2次元配列に加工し変数`digit`に代入します。"""

im = Image.open(filename)
im_width, im_height= im.size
square_len = min(im.size)
im = im.crop(((im_width - square_len) // 2,(im_height - square_len) // 2,
(im_width + square_len) // 2,(im_height + square_len) // 2)) # 正方形に切り取り
im = ImageEnhance.Brightness(im).enhance(2.0) # 輝度変更
im = im.convert('L') # グレースケール
im =  ImageOps.invert(im) # 白黒反転
im = im.resize((8, 8), Image.LANCZOS) # リサイズ
digit = np.asarray(im)
digit = np.round(16 * (digit / 255)) # 画素値変更
plt.imshow(digit, cmap='gray_r')
plt.show()
print(digit)

"""## Q1
上記で作成した形状が`(8, 8)`の2次元配列`digit`を形状`(64,)`の1次元配列に変換し変数`digit`に代入してください。

`digit`は

`[0. 0. 2. 5. 5. 3. 0. 0. 0. 0. 4. 2. 1. 6. 1. 0. 0. 0. 3. 1. 0. 5. 3. 0. 0. 0. 1. 5. 6. 7. 1. 0. 0. 0. 1. 6. 6. 5. 0. 0. 0. 0. 6. 2. 0. 5. 3. 0. 0. 0. 4. 2. 3. 6. 1. 0. 0. 0. 1. 5. 6. 2. 0. 0.]`

となります。



"""

digit = digit.flatten()
print(digit)
print(digit.shape)

"""## Q2
引数`vec1`と`vec2`それぞれにベクトルを表す1次元配列が与えられ、それらのベクトル間のコサイン類似度を返り値として返す関数`compute_cosine_sim`を実装してください。
"""

def compute_cosine_sim(vec1, vec2):
  return np.dot(vec1, vec2) / (np.linalg.norm(vec1) * np.linalg.norm(vec2))

"""## Q3
引数`X`にデータセットを表す2次元配列、引数`digit`に画像を表す1次元配列をそれぞれ受け取り、`digit`と最もコサイン類似度が高い画像に対応する`X`の行インデックスとその類似度を返す以下の関数`find_similar_image`を実装してください。
"""

def find_similar_image(X, digit):
  values = [compute_cosine_sim(data, digit) for data in X]
  max_value = max(values)
  return values.index(max_value), max_value

"""次のように関数`find_similar_image`を実行すると、先に用意した手書き数字画像と最もコサイン類似度が高い画像に対応する`X`の行インデックスは513、その類似度は約0.95となります。"""

image_ind, similarity = find_similar_image(X, digit)
print(image_ind)
print(similarity)

"""類似度が最も高い画像の1次元のピクセルデータは次のようになっています。"""

print(digits.data[image_ind])

"""以下に、その実際の画像を示します。"""

plt.imshow(digits.images[image_ind], cmap='gray_r')
plt.show()

"""## Q4
引数`X`にデータセットを表す2次元配列、引数`digit`に画像を表す1次元配列、引数`k`に正の整数値をそれぞれ受け取り、`digit`とのコサイン類似度が上位`k`個の画像に対応する`X`の行インデックスを要素とするリストを返す以下の関数`find_nearest_images`を実装してください。

単純のため類似度が重複する画像はないものとします。

"""

def find_nearest_images(X, digit, k):
  values = [compute_cosine_sim(data, digit) for data in X]
  result = np.argsort(values)[-k:][::-1]
  return result.tolist()

"""次のように関数`find_nearest_images`を実行すると、先に用意した手書き数字画像とのコサイン類似度が上位10個の画像に対応する`X`の行インデックスを要素とするリストは

`[513, 978, 1455, 768, 424, 296, 394, 1028, 515, 943]`

となります。
"""

nearest_images = find_nearest_images(X, digit, 10)
nearest_images

"""これらの類似画像のラベルの中で最も頻度の高いラベルをもとに、次のように先に用意した手書き数字画像のラベルを推定することができます。"""

labels = {}
for i in nearest_images:
  labels[y[i]] = labels.get(y[i], 0) + 1
most_freq = max(labels.values())
predicted_label = [k for k, v in labels.items() if v == most_freq]
predicted_label

"""## 参考
主成分分析により先に用意した画像とデータセットの各画像を2次元に削減し可視化
"""

pca = PCA(n_components=2).fit(X)
X_pca = pca.transform(X)
x_min, x_max = np.min(X_pca, axis=0), np.max(X_pca, axis=0)
X_pca = (X_pca - x_min) / (x_max - x_min)
plt.figure(figsize=(10, 8))
for i in range(len(X)):
    plt.text(X_pca[i, 0], X_pca[i, 1], str(y[i]), color=plt.cm.nipy_spectral(y[i] / 10.), fontdict={'weight': 'roman', 'size': 'small'})
digit_pca = pca.transform(digit.reshape(1,-1))
digit_pca = (digit_pca - x_min) / (x_max - x_min)
plt.text(digit_pca[0, 0], digit_pca[0, 1], '8', color='black', fontdict={'weight': 'bold', 'size': 'xx-large'})
plt.xlabel('Principal Component 1')
plt.ylabel('Principal Component 2')
plt.show()

